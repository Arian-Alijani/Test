name: V2Ray Windows VPN (VLESS+REALITY)

on:
  push:
    branches:
      - "**"
  workflow_dispatch:
    inputs:
      connection_mode:
        description: "Choose connection type"
        required: true
        type: choice
        default: "v2ray"
        options:
          - v2ray
          - ssh
      cloudflare_sni:
        description: "Cloudflare hostname for REALITY SNI (example: www.cloudflare.com)"
        required: false
        default: "www.cloudflare.com"
      ssh_port:
        description: "SSH listening port (used only in ssh mode)"
        required: false
        default: "443"
      ssh_username:
        description: "SSH username (used only in ssh mode)"
        required: false
        default: "ghssh"

jobs:
  v2ray-server:
    if: ${{ github.event_name == 'push' || github.event.inputs.connection_mode == 'v2ray' }}
    runs-on: windows-latest
    timeout-minutes: 360

    steps:
      - name: Prepare server variables
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # Core parameters (change only if needed)
          $port = 443
          $serverName = "${{ github.event.inputs.cloudflare_sni }}"
          if ([string]::IsNullOrWhiteSpace($serverName)) {
            $serverName = "www.cloudflare.com"
          }
          $serverName = $serverName.Trim()
          $serverName = ($serverName -replace '^https?://', '').Split('/')[0]
          $fingerprint = "chrome"

          # Generate secure server values
          $uuid = [guid]::NewGuid().ToString()
          $shortIdBytes = New-Object 'System.Byte[]' 8
          [System.Security.Cryptography.RandomNumberGenerator]::Create().GetBytes($shortIdBytes)
          $shortId = ($shortIdBytes | ForEach-Object { $_.ToString("x2") }) -join ''

          "XRAY_PORT=$port" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "XRAY_UUID=$uuid" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "XRAY_SNI=$serverName" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "XRAY_FP=$fingerprint" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "XRAY_SHORT_ID=$shortId" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

          Write-Host "[INFO] Base parameters generated."
          Write-Host "[INFO] Port: $port | SNI: $serverName | Fingerprint: $fingerprint"

      - name: Download and extract Xray
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $downloadUrl = "https://github.com/XTLS/Xray-core/releases/latest/download/Xray-windows-64.zip"
          $zipPath = "$env:RUNNER_TEMP\\xray.zip"
          $installDir = "C:\\xray"

          Write-Host "[INFO] Downloading latest Xray from stable direct URL..."
          Write-Host "[INFO] URL: $downloadUrl"
          Invoke-WebRequest -Uri $downloadUrl -OutFile $zipPath

          if (Test-Path $installDir) {
            Remove-Item -Recurse -Force $installDir
          }
          New-Item -ItemType Directory -Path $installDir | Out-Null

          Expand-Archive -Path $zipPath -DestinationPath $installDir -Force

          if (-not (Test-Path "C:\\xray\\xray.exe")) {
            throw "xray.exe was not found after extraction."
          }

          "XRAY_DIR=$installDir" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          Write-Host "[INFO] Xray installed at: $installDir"
          & "C:\\xray\\xray.exe" version

      - name: Generate REALITY keypair
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $xrayExe = "${env:XRAY_DIR}\\xray.exe"

          Write-Host "[INFO] Generating X25519 keypair for REALITY..."
          $keysRaw = (& $xrayExe x25519 2>&1 | Out-String).Trim()
          Write-Host "[DEBUG] x25519 raw output:"
          Write-Host $keysRaw

          $privateMatch = [regex]::Match($keysRaw, '(?im)(?:private\s*key|privatekey)\s*:\s*([A-Za-z0-9_\-+=\/]+)')
          $publicMatch = [regex]::Match($keysRaw, '(?im)(?:public\s*key|publickey)\s*:\s*([A-Za-z0-9_\-+=\/]+)')
          $passwordMatch = [regex]::Match($keysRaw, '(?im)password\s*:\s*([A-Za-z0-9_\-+=\/]+)')

          $privateKey = if ($privateMatch.Success) { $privateMatch.Groups[1].Value } else { "" }
          $publicKey = if ($publicMatch.Success) {
            $publicMatch.Groups[1].Value
          } elseif ($passwordMatch.Success) {
            Write-Host "[WARN] Public key not found. Using 'Password' field from xray output as client key."
            $passwordMatch.Groups[1].Value
          } else {
            ""
          }

          if (-not $privateKey -or -not $publicKey) {
            throw "Failed to parse REALITY keypair from xray x25519 output."
          }

          "XRAY_PRIVATE_KEY=$privateKey" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "XRAY_PUBLIC_KEY=$publicKey" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

          Write-Host "[INFO] REALITY keypair generated successfully."

      - name: Create Xray server config
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $configPath = "${env:XRAY_DIR}\\config.json"

          $configObj = @{
            log = @{
              loglevel = "debug"
            }
            inbounds = @(
              @{
                listen = "0.0.0.0"
                port = [int]$env:XRAY_PORT
                protocol = "vless"
                settings = @{
                  clients = @(
                    @{
                      id = "$env:XRAY_UUID"
                      flow = "xtls-rprx-vision"
                      email = "gha-user"
                    }
                  )
                  decryption = "none"
                }
                streamSettings = @{
                  network = "tcp"
                  security = "reality"
                  realitySettings = @{
                    show = $false
                    dest = "${env:XRAY_SNI}:443"
                    xver = 0
                    serverNames = @("$env:XRAY_SNI")
                    privateKey = "$env:XRAY_PRIVATE_KEY"
                    shortIds = @("$env:XRAY_SHORT_ID")
                  }
                }
              }
            )
            outbounds = @(
              @{
                protocol = "freedom"
                settings = @{}
              }
            )
          }

          $configObj | ConvertTo-Json -Depth 20 | Out-File -FilePath $configPath -Encoding ascii -Force
          Write-Host "[INFO] Xray config written to: $configPath"
          Write-Host "[INFO] Validating config..."
          & "${env:XRAY_DIR}\\xray.exe" -test -c $configPath

      - name: Open firewall port
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          netsh advfirewall firewall delete rule name="Xray-VLESS-REALITY" | Out-Null
          netsh advfirewall firewall add rule name="Xray-VLESS-REALITY" dir=in action=allow protocol=TCP localport=${env:XRAY_PORT}
          Write-Host "[INFO] Firewall rule applied for TCP/${env:XRAY_PORT}."

      - name: Start server, print URI, and keep alive
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $xrayExe = "${env:XRAY_DIR}\\xray.exe"
          $configPath = "${env:XRAY_DIR}\\config.json"
          $stdoutLogPath = "${env:XRAY_DIR}\\xray-runtime.out.log"
          $stderrLogPath = "${env:XRAY_DIR}\\xray-runtime.err.log"

          Write-Host "[INFO] Starting Xray in background..."
          $proc = Start-Process -FilePath $xrayExe -ArgumentList "run", "-c", $configPath -RedirectStandardOutput $stdoutLogPath -RedirectStandardError $stderrLogPath -PassThru
          Start-Sleep -Seconds 5

          if ($proc.HasExited) {
            Write-Host "[ERROR] Xray exited immediately. Dumping log:"
            if (Test-Path $stdoutLogPath) {
              Write-Host "[ERROR] Last stdout lines:"
              Get-Content $stdoutLogPath -Tail 200
            }
            if (Test-Path $stderrLogPath) {
              Write-Host "[ERROR] Last stderr lines:"
              Get-Content $stderrLogPath -Tail 200
            }
            throw "Xray process is not running."
          }

          Write-Host "[INFO] Xray started with PID: $($proc.Id)"
          Write-Host "[INFO] Detecting public IP..."
          $publicIp = (Invoke-RestMethod -Uri "https://api.ipify.org").ToString().Trim()
          if (-not $publicIp) {
            throw "Could not detect public IP."
          }

          $uri = "vless://${env:XRAY_UUID}@${publicIp}:${env:XRAY_PORT}?encryption=none&flow=xtls-rprx-vision&security=reality&sni=${env:XRAY_SNI}&fp=${env:XRAY_FP}&pbk=${env:XRAY_PUBLIC_KEY}&sid=${env:XRAY_SHORT_ID}&type=tcp&headerType=none#GitHubActions-Windows"

          Write-Host ""
          Write-Host "==================== V2RAY OUTPUT ===================="
          Write-Host "Public IP: $publicIp"
          Write-Host "Port: ${env:XRAY_PORT}"
          Write-Host "UUID: ${env:XRAY_UUID}"
          Write-Host "PublicKey: ${env:XRAY_PUBLIC_KEY}"
          Write-Host "ShortID: ${env:XRAY_SHORT_ID}"
          Write-Host "SNI: ${env:XRAY_SNI}"
          Write-Host ""
          Write-Host "VLESS URI (import this in your client):"
          Write-Host "$uri"
          Write-Host "======================================================"
          Write-Host ""

          "### VLESS + REALITY" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          $uri | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append

          $ErrorActionPreference = "Continue"
          Write-Host "[INFO] Entering diagnostics loop. Workflow keeps server alive until timeout/cancel."

          while ($true) {
            $now = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            Write-Host "[$now] [HEALTH] Checking process + port status..."

            $liveProc = Get-Process -Id $proc.Id -ErrorAction SilentlyContinue
            if (-not $liveProc) {
              Write-Host "[$now] [ERROR] Xray process not found. Printing last logs and exiting."
              if (Test-Path $stdoutLogPath) {
                Write-Host "[$now] [LOG] Last 200 stdout lines:"
                Get-Content $stdoutLogPath -Tail 200
              }
              if (Test-Path $stderrLogPath) {
                Write-Host "[$now] [LOG] Last 200 stderr lines:"
                Get-Content $stderrLogPath -Tail 200
              }
              exit 1
            }

            $conn = Get-NetTCPConnection -State Listen -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq [int]${env:XRAY_PORT} }
            if (-not $conn) {
              Write-Host "[$now] [WARN] Port ${env:XRAY_PORT} is not in LISTEN state."
            } else {
              Write-Host "[$now] [OK] Xray PID=$($proc.Id) listening on TCP/${env:XRAY_PORT}."
            }

            if (Test-Path $stdoutLogPath) {
              Write-Host "[$now] [LOG] Last 25 stdout lines:"
              Get-Content $stdoutLogPath -Tail 25
            }
            if (Test-Path $stderrLogPath) {
              Write-Host "[$now] [LOG] Last 25 stderr lines:"
              Get-Content $stderrLogPath -Tail 25
            }

            Start-Sleep -Seconds 120
          }

  ssh-server:
    if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.connection_mode == 'ssh' }}
    runs-on: windows-latest
    timeout-minutes: 360

    steps:
      - name: Prepare SSH variables
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $sshPortText = "${{ github.event.inputs.ssh_port }}"
          if ([string]::IsNullOrWhiteSpace($sshPortText)) {
            $sshPortText = "443"
          }

          [int]$sshPort = 0
          if (-not [int]::TryParse($sshPortText, [ref]$sshPort)) {
            throw "Invalid ssh_port. It must be a number."
          }
          if ($sshPort -lt 1 -or $sshPort -gt 65535) {
            throw "Invalid ssh_port range. Use 1..65535."
          }

          $sshUser = "${{ github.event.inputs.ssh_username }}"
          if ([string]::IsNullOrWhiteSpace($sshUser)) {
            $sshUser = "ghssh"
          }
          $sshUser = $sshUser.Trim()
          if ($sshUser -notmatch '^[a-zA-Z0-9._-]{3,20}$') {
            throw "Invalid ssh_username. Allowed: a-z, A-Z, 0-9, . _ - (3..20 chars)."
          }

          Add-Type -AssemblyName System.Security
          $charSet = @{
            Upper   = [char[]](65..90)
            Lower   = [char[]](97..122)
            Number  = [char[]](48..57)
            Special = ([char[]](33..47) + [char[]](58..64) + [char[]](91..96) + [char[]](123..126))
          }
          $rawPassword = @()
          $rawPassword += $charSet.Upper   | Get-Random -Count 4
          $rawPassword += $charSet.Lower   | Get-Random -Count 4
          $rawPassword += $charSet.Number  | Get-Random -Count 4
          $rawPassword += $charSet.Special | Get-Random -Count 4
          $sshPass = -join ($rawPassword | Sort-Object { Get-Random })

          "SSH_PORT=$sshPort" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "SSH_USER=$sshUser" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "SSH_PASS=$sshPass" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

          Write-Host "[INFO] SSH variables prepared."
          Write-Host "[INFO] Port: $sshPort | Username: $sshUser"

      - name: Configure SSH server, print access, and keep alive
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          Write-Host "[INFO] Installing OpenSSH.Server capability if required..."
          $cap = Get-WindowsCapability -Online | Where-Object { $_.Name -like 'OpenSSH.Server*' } | Select-Object -First 1
          if (-not $cap) {
            throw "OpenSSH.Server capability was not found on this runner."
          }
          if ($cap.State -ne "Installed") {
            Add-WindowsCapability -Online -Name $cap.Name
          }

          $securePass = ConvertTo-SecureString $env:SSH_PASS -AsPlainText -Force
          $existingUser = Get-LocalUser -Name $env:SSH_USER -ErrorAction SilentlyContinue
          if ($existingUser) {
            Write-Host "[INFO] SSH user exists. Resetting password..."
            Set-LocalUser -Name $env:SSH_USER -Password $securePass
          } else {
            Write-Host "[INFO] Creating SSH user..."
            New-LocalUser -Name $env:SSH_USER -Password $securePass -AccountNeverExpires -PasswordNeverExpires
            Add-LocalGroupMember -Group "Users" -Member $env:SSH_USER
          }

          $sshdConfigPath = "$env:ProgramData\\ssh\\sshd_config"
          if (-not (Test-Path $sshdConfigPath)) {
            throw "sshd_config not found at $sshdConfigPath"
          }

          $script:configLines = Get-Content $sshdConfigPath
          function Set-SshdOption([string]$Key, [string]$Value) {
            $pattern = "^[#\s]*$Key\s+.*$"
            $line = "$Key $Value"
            if ($script:configLines -match $pattern) {
              $script:configLines = $script:configLines | ForEach-Object {
                if ($_ -match $pattern) { $line } else { $_ }
              }
            } else {
              $script:configLines += $line
            }
          }

          Set-SshdOption -Key "Port" -Value "$env:SSH_PORT"
          Set-SshdOption -Key "PasswordAuthentication" -Value "yes"
          Set-SshdOption -Key "PubkeyAuthentication" -Value "yes"
          Set-SshdOption -Key "PermitEmptyPasswords" -Value "no"
          Set-SshdOption -Key "AllowTcpForwarding" -Value "yes"
          Set-SshdOption -Key "GatewayPorts" -Value "no"
          Set-SshdOption -Key "AllowUsers" -Value "$env:SSH_USER"

          $script:configLines | Set-Content -Path $sshdConfigPath -Encoding ascii
          Write-Host "[INFO] sshd_config updated."

          netsh advfirewall firewall delete rule name="SSH-VPN-Custom" | Out-Null
          netsh advfirewall firewall add rule name="SSH-VPN-Custom" dir=in action=allow protocol=TCP localport=$env:SSH_PORT
          Write-Host "[INFO] Firewall rule applied for TCP/$env:SSH_PORT."

          Set-Service -Name sshd -StartupType Automatic
          Restart-Service -Name sshd -Force
          Start-Sleep -Seconds 3

          $svc = Get-Service -Name sshd -ErrorAction Stop
          if ($svc.Status -ne "Running") {
            throw "sshd service is not running."
          }

          $listen = Get-NetTCPConnection -State Listen -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq [int]$env:SSH_PORT }
          if (-not $listen) {
            throw "sshd is not listening on port $env:SSH_PORT."
          }

          $publicIp = (Invoke-RestMethod -Uri "https://api.ipify.org").ToString().Trim()
          if (-not $publicIp) {
            throw "Could not detect public IP."
          }

          $sshCmd = "ssh $env:SSH_USER@$publicIp -p $env:SSH_PORT"
          $socksCmd = "ssh -N -D 127.0.0.1:1080 $env:SSH_USER@$publicIp -p $env:SSH_PORT"

          Write-Host ""
          Write-Host "==================== SSH OUTPUT ===================="
          Write-Host "Public IP: $publicIp"
          Write-Host "Port: $env:SSH_PORT"
          Write-Host "Username: $env:SSH_USER"
          Write-Host "Password: $env:SSH_PASS"
          Write-Host ""
          Write-Host "SSH connect:"
          Write-Host "$sshCmd"
          Write-Host ""
          Write-Host "SOCKS5 VPN-like tunnel:"
          Write-Host "$socksCmd"
          Write-Host "===================================================="
          Write-Host ""

          "### SSH Access" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          "Host: $publicIp" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          "Port: $env:SSH_PORT" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          "Username: $env:SSH_USER" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          "Password: $env:SSH_PASS" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          "SOCKS command:" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
          $socksCmd | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append

          $ErrorActionPreference = "Continue"
          Write-Host "[INFO] Entering SSH diagnostics loop. Workflow keeps server alive until timeout/cancel."
          while ($true) {
            $now = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            $svc = Get-Service -Name sshd -ErrorAction SilentlyContinue
            if (-not $svc -or $svc.Status -ne "Running") {
              Write-Host "[$now] [ERROR] sshd service is not running."
              Get-WinEvent -LogName "OpenSSH/Operational" -MaxEvents 20 -ErrorAction SilentlyContinue | `
                Select-Object TimeCreated, Id, LevelDisplayName, Message | Format-List
              exit 1
            }

            $listen = Get-NetTCPConnection -State Listen -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq [int]$env:SSH_PORT }
            if (-not $listen) {
              Write-Host "[$now] [WARN] sshd is not listening on TCP/$env:SSH_PORT."
            } else {
              Write-Host "[$now] [OK] sshd running and listening on TCP/$env:SSH_PORT."
            }

            Start-Sleep -Seconds 120
          }
